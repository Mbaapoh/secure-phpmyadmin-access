# Template for ALL SSL-ENABLED sites.
# Uses __skip_letsencrypt var (passed by tasks) to toggle between snakeoil (for ACME pass) and real certs (final pass).
################################################################################
# This file was generated by Ansible for {{ ansible_fqdn }}
# Do NOT modify this file by hand!
################################################################################

{% if item.key == "default" and item.value.ssl | default(false) %}
# Default HTTP server block (catch-all on port 80, redirects to default HTTPS)
server {
    listen        {{ item.value.listen | default(80) }} default_server;
    listen   [::]:{{ item.value.listen | default(80) }} default_server;
    server_name _;
    access_log /var/log/nginx/{{ item.key | replace('.', '_') }}.http.access.log timed_combined;
    error_log /var/log/nginx/{{ item.key | replace('.', '_') }}.http.error.log warn;
    return        301 https://$host$request_uri; # Redirect to HTTPS
}

# Default HTTPS server block (catch-all on port 443 with snakeoil)
server {
   listen        {{ item.value.listen_ssl | default(443) }} ssl http2 default_server;
   listen   [::]:{{ item.value.listen_ssl | default(443) }} ssl http2 default_server;
   server_name _;
   access_log /var/log/nginx/{{ item.key | replace('.', '_') }}.https.access.log timed_combined;
   error_log /var/log/nginx/{{ item.key | replace('.', '_') }}.https.error.log warn;

   # Standard snakeoil certificates provided by ssl-cert package
   ssl_certificate /etc/ssl/certs/ssl-cert-snakeoil.pem;
   ssl_certificate_key /etc/ssl/private/ssl-cert-snakeoil.key;

   # Secure SSL settings for default server
   ssl_protocols TLSv1.2 TLSv1.3;
   ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384';
   ssl_prefer_server_ciphers off; # Modern recommendation
   ssl_session_cache shared:SSL:10m;
   ssl_session_timeout 1d;
   ssl_session_tickets off; # For better Perfect Forward Secrecy

   return        444; # Or a default holding page
}

{% elif item.value.ssl | default(false) %} {# Actual SSL site configurations #}
upstream {{ item.key | replace('.', '_') }}_backend  { # Dots replaced for valid upstream name
{% for upstream_server in item.value.upstreams %}
    server {{ upstream_server.backend_address }}:{{ upstream_server.backend_port }} weight={{ upstream_server.weight | default(1) }}{% if 'params' in upstream_server and upstream_server.params %} {{ upstream_server.params | trim }}{% endif %};
{% endfor %}
}

# HTTP Server Block: Redirects to HTTPS and serves ACME challenges
server {
   listen         {{ item.value.listen | default(80) }};
   listen    [::]:{{ item.value.listen | default(80) }};
   server_name    {{ item.value.domains | join(' ') }};

   access_log /var/log/nginx/{{ item.key | replace('.', '_') }}.http_redirect.access.log timed_combined;
   error_log /var/log/nginx/{{ item.key | replace('.', '_') }}.http_redirect.error.log warn;

   # ACME challenge location is always needed if this site might ever use Let's Encrypt
   location /.well-known/acme-challenge/ {
      root /var/www/{{ item.key }}; # Nginx will look for files in /var/www/{{item.key}}/.well-known/acme-challenge/
                                    # Ensure your webroot creation task in Ansible creates this full path or that Certbot does.
   }

   location / {
      return 301 https://$host$request_uri; # Use $host for reliability
   }
   {{ item.value.custom_http_redirect_directives | default('') }}
}

# HTTPS Server Block
server {
   listen        {{ item.value.listen_ssl | default(443) }} ssl http2;
   listen   [::]:{{ item.value.listen_ssl | default(443) }} ssl http2;
   server_name {{ item.value.domains | join(' ') }};

   access_log /var/log/nginx/{{ item.key | replace('.', '_') }}.https.access.log timed_combined;
   error_log /var/log/nginx/{{ item.key | replace('.', '_') }}.https.error.log error;

   # --- SSL Certificate Configuration ---
   {% if item.value.letsencrypt | default(false) and not (__skip_letsencrypt | default(false) | bool) %}
   # Using Let's Encrypt certs (this runs when __skip_letsencrypt is false, i.e., final pass after LE run)
   ssl_certificate /etc/letsencrypt/live/{{ item.key }}/fullchain.pem; # Uses item.key as per your certbot --cert-name
   ssl_certificate_key /etc/letsencrypt/live/{{ item.key }}/privkey.pem; # Uses item.key
     {% if le_options_ssl_nginx_exists_on_host | default(false) %} {# Fact set by tasks/main.yml #}
   include /etc/letsencrypt/options-ssl-nginx.conf;
     {% else %}
   # Fallback strong SSL settings if options-ssl-nginx.conf is missing (SHOULD NOT HAPPEN ideally if LE succeeded)
   ssl_protocols TLSv1.2 TLSv1.3;
   ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384';
   ssl_prefer_server_ciphers off;
   ssl_session_cache shared:SSL:10m;
   ssl_session_timeout 1d;
   ssl_session_tickets off;
     {% endif %}
     {% if le_ssl_dhparams_exists_on_host | default(false) %} {# Fact set by tasks/main.yml #}
   ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
     {% endif %}
   {% elif item.value.custom_cert_path is defined and item.value.custom_key_path is defined %}
   # Using custom-defined SSL certificates
   ssl_certificate {{ item.value.custom_cert_path }};
   ssl_certificate_key {{ item.value.custom_key_path }};
   ssl_protocols TLSv1.2 TLSv1.3; # Specify strong settings for custom certs
   ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384';
   ssl_prefer_server_ciphers off;
   ssl_session_cache shared:SSL:10m;
   ssl_session_timeout 1d;
   ssl_session_tickets off;
   {% else %}
   # Fallback to snakeoil (e.g., initial setup for LE when __skip_letsencrypt is true, or if SSL true but no other certs specified)
   ssl_certificate {{ item.value.ssl_certificate | default('/etc/ssl/certs/ssl-cert-snakeoil.pem') }};
   ssl_certificate_key {{ item.value.ssl_certificate_key | default('/etc/ssl/private/ssl-cert-snakeoil.key') }};
   ssl_protocols TLSv1.2 TLSv1.3;
   ssl_ciphers 'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384'; # Basic secure ciphers for snakeoil
   ssl_session_cache shared:SSL:10m; # Using values from your original default server block
   ssl_session_timeout 5m;        # Using values from your original default server block
   {% endif %}
   # --- End SSL Certificate Configuration ---

   
   {% if item.value.hsts_max_age is defined %}
   # Security Headers (at server level)
   add_header Strict-Transport-Security "max-age={{ item.value.hsts_max_age }}; includeSubDomains; preload" always;
   {% else %}
   add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always; # Sensible default HSTS
   {% endif %}
   # X-Frame-Options & X-Content-Type-Options are set globally in nginx.conf.j2.
   # If you need to override them per site, you can do so here.
   # Your original template had them here:
   # add_header X-Frame-Options "SAMEORIGIN" always;
   # add_header X-Content-Type-Options "nosniff" always;
   # add_header X-XSS-Protection "1; mode=block" always; # This header is deprecated; X-Content-Type-Options is preferred

   # ACME challenge location (can also be served over HTTPS if LE client tries after redirect)
   location /.well-known/acme-challenge/ {
      root /var/www/{{ item.key }};
   }

   location / {
    {% if item.value.redirect_url is defined %}
    return 301 {{ item.value.redirect_url }};
    {% else %}
    
    {% if item.value.whitelist is defined %}
    {% for iprange in item.value.whitelist %}
    # Whitelisted IPs
    allow {{ iprange }};
    {% endfor %}
    deny all;
    {% endif %}

    
    {% if item.value.nginx_cors_enabled | default(false) | bool and item.value.cors_accept_origins is defined and item.value.cors_accept_origins %}
    # CORS Headers
    set $cors_allowed_origin "";
    {% for origin_host_pattern in item.value.cors_accept_origins %}
    if ($http_origin = "https://{{ origin_host_pattern }}") {
        set $cors_allowed_origin $http_origin;
    }
    if ($http_origin = "http://{{ origin_host_pattern }}") {
        set $cors_allowed_origin $http_origin;
    }
    {% endfor %}

    # These headers are added if the main Jinja 'if' for CORS is true.
    add_header 'Access-Control-Allow-Origin' "$cors_allowed_origin" always;
    add_header 'Access-Control-Allow-Credentials' 'true' always;
    add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, PUT, DELETE, PATCH' always;
    add_header 'Access-Control-Allow-Headers' 'Content-Type, Authorization, X-Requested-With, Accept, Origin' always;

    
    if ($request_method = 'OPTIONS') {
        # --- Handle CORS preflight (OPTIONS) requests ---
        add_header 'Access-Control-Allow-Origin' "$cors_allowed_origin" always;
        add_header 'Access-Control-Allow-Credentials' 'true' always;
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, PUT, DELETE, PATCH' always;
        add_header 'Access-Control-Allow-Headers' 'Content-Type, Authorization, X-Requested-With, Accept, Origin' always;
        add_header 'Access-Control-Max-Age' 1728000 always;
        add_header 'Content-Length' 0 always;
        add_header 'Content-Type' 'text/plain; charset=utf-8' always;
        return 204;
    }

    # Hide backend CORS headers to avoid conflicts
    proxy_hide_header "Access-Control-Allow-Origin";
    proxy_hide_header "Access-Control-Allow-Credentials";
    proxy_hide_header "Access-Control-Allow-Methods";
    proxy_hide_header "Access-Control-Allow-Headers";
    proxy_hide_header "Access-Control-Expose-Headers";
    proxy_hide_header "Access-Control-Max-Age";
    {% endif %}

    include /etc/nginx/{{ nginx_proxy_params_file | default('snippets/hardened_proxy.conf') }};

    {% if item.value.proxy_ssl_verify is defined %}
    proxy_ssl_verify {{ 'on' if item.value.proxy_ssl_verify | bool else 'off' }};
    {% endif %}

  
    fastcgi_read_timeout {{ item.value.fastcgi_read_timeout | default(nginx_fastcgi_read_timeout | default(300)) }}s;
    proxy_pass {{ item.value.backend_protocol | default('http') }}://{{ item.key | replace('.', '_') }}_backend;

    {% if item.value.auth is defined %}
    auth_basic "Restricted Content";
    auth_basic_user_file "/etc/nginx/{{ item.key | replace('.', '_') }}_htpasswd";
    {% endif %}

    {{ item.value.custom_https_location_directives | default('') }}
    {% endif %}
   }

   {{ item.value.custom_https_server_directives | default('') }}
}
{% endif %} {# End if item.value.ssl (for actual sites) #}